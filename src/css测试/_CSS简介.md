
## CSS 基础:
    和 HTML 类似，CSS 也不是真正的编程语言，甚至不是标记语言。CSS 是一门样式表语言，这也就是说人们可以用它来选择性地为 HTML 元素添加样式。
    CSS（层叠样式表）用于设置和布置网页——例如，更改内容的字体、颜色、大小和间距，将其拆分为多个列，或添加动画和其他装饰功能。
    CSS 中的 C 代表“层叠”。这是样式层叠在一起的方法。

## CSS 规则集：
    1、因为css本来就是样式表语言，也就是从表格里拿出样式去填充内容的意思，而表格里就制定了很多规则，用这些规则去描述对应元素的样式。
    2、一个规则集的组成，就是css表格里面由很多个规则集组成，一个规则集则是一个样式的最基本结构：
        p {
          color: red;
          width: 500px;
          border: 1px solid black;
        }
        选择器（Selector）
            HTML 元素的名称位于规则集开始。它选择了一个或多个需要添加样式的元素（在这个例子中就是 <p> 元素）。要给不同元素添加样式，只需要更改选择器。

        声明（Declaration）
            一个单独的规则，如 color: red; 用来指定添加样式元素的属性。

        属性（Properties）
            改变 HTML 元素样式的途径（本例中 color 就是 <p> 元素的属性）。CSS 中，由编写人员决定修改哪个属性以改变规则。

        属性的值（Property value）
            在属性的右边，冒号后面即属性的值，它从指定属性的众多外观中选择一个值（我们除了 red 之外还有很多属性值可以用于 color ）。

        注意其他重要的语法：
            除了选择器部分，每个规则集都应该包含在成对的大括号里（{}）。
            在每个声明里要用冒号（:）将属性与属性值分隔开。
            在每个规则集里要用分号（;）将各个声明分隔开。

## 选择器：
    1、选择器有许多不同的类型。上面只介绍了元素选择器，用来选择 HTML 文档中给定的元素。但是选择操作可以更加具体。下面是一些常用的选择器类型：
        元素选择器（也称作标签或类型选择器）： 所有指定类型的 HTML 元素 	
                例如： p 选择 <p>
        ID 选择器 ：具有特定 ID 的元素。单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID 	
                例如： #my-id 选择 <p id="my-id"> 或 <a id="my-id">
        类选择器：具有特定类的元素。单一页面中，一个类可以有多个实例 
                例如：.my-class  选择 <p class="my-class"> 和 <a class="my-class">
        属性选择器：拥有特定属性的元素 	
                例如：img[src] 选择 <img src="myimage.png"> 但不是 <img>
        伪类选择器：特定状态下的特定元素（比如鼠标指针悬停于链接之上） 	
                例如：a:hover 选择仅在鼠标指针悬停在链接上时的 <a> 元素
     更多的选择器去看文档。

     2、选择器列表：在选择器之间加上一个逗号，就变为选择器列表。
                  当你使用选择器列表时，如果任何一个选择器无效 (存在语法错误)，那么整条规则都会被忽略。

    3、全局选择器：全局选择器，是由一个星号（*）代指的，它选中了文档中的所有内容（或者是父元素中的所有内容，比如，它紧随在其他元素以及邻代运算符之后的时候）。

    4、用户行为伪类：
        :hover——上面提到过，只会在用户将指针挪到元素上的时候才会激活，一般就是链接元素。
        :focus——只会在用户使用键盘控制，选定元素的时候激活。
      伪元素开头为双冒号::。
        用于格式化一个元素内容的某一部分，例如只格式化<span>元素内容的第一行：p::first-line。
        甚至可以给元素添加内容，表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。

## 层叠、优先级与继承：
    1、层叠：在做一个项目过程中你会发现一些应该产生效果的样式没有生效。通常的原因是你创建了两个应用于同一个元素的规则，这种行为就叫做层叠。
            当应用两条同级别的规则到一个元素的时候，写在后面的就是实际使用的规则。
            优先级：
                1.一个元素选择器不是很具体，则会选择页面上该类型的所有元素，所以它的优先级就会低一些。
                2.一个类选择器稍微具体点，则会选择该页面中有特定 class 属性值的元素，所以它的优先级就要高一点。
                
            层叠运用规则时的排序(越后越重要)：
                1.资源顺序：最后面的规则会应用，可以理解为后面的规则覆盖前面的规则。
                2.优先级: 选择的范围越小越具体，优先级越高，ID选择器 > 类选择器 > 元素选择器。
                        通用选择器（*）、组合符（+、>、~、' '）和调整优先级的选择器（:where()）不会影响优先级。
                        内联样式，即 style 属性内的样式声明，优先于所有普通的样式，无论其优先级如何。
                3.重要程度：
                    !important属性值：强烈建议除了非常情况不要使用它，用来覆盖所有上面所有优先级计算。


    2、继承：在默认情况下，一些 css 属性继承当前元素的父元素上设置的值，有些则不继承。这也可能导致一些和期望不同的结果。
            尽管每个 CSS 属性页都列出了属性是否被继承，但我们通常可以通过常识来判断哪些属性属于默认继承。

        CSS 为控制继承提供了五个特殊的通用属性值。每个 CSS 属性都接收这些值，是值：
            inherit
                设置该属性会使子元素属性和父元素相同。实际上，就是“开启继承”。

            initial
                将应用于选定元素的属性值设置为该属性的初始值。

            revert (en-US)
                将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。在许多情况下，此值的作用类似于 unset。

            revert-layer (en-US)
                将应用于选定元素的属性值重置为在上一个层叠层中建立的值。

            unset
                将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样

        all属性：把麾下的所有元素的继承属性的值都设置为这个值。
            例如 .fix-this {
                  all: unset;
                }

## 层叠层：
    1、层叠层是显式优先级容器，层内的规则层叠在一起，而不会与层外的样式规则竞争。
        我的理解是，样式的来源是一层，然后样式的文件是一层，然后文件里的@layer声明又是一层，就是打包为一组的样式规则集，就是一包东西。
        层的优先权始终高于选择器的优先级。具有优先权的层中的样式“胜出”于具有较低优先权的层。输掉的层中选择器的优先级是无关紧要的。

    2、所谓层叠来源，也就是css文件的来源，样式的来源。
        “用户代理”指的是浏览器。“用户”指的是是网站访问者。“作者”指的是你，开发者。
        样式的来源以及重要的顺序(越后越重要)：
            1.用户代理普通样式
            2.用户普通样式
            3.作者普通样式
            4.正在动画的样式
            5.作者重要样式  (重要样式是指属性值中有 !important 值)
            6.用户重要样式
            7.用户代理重要样式
            8.正在过渡的样式
    3、使用 @layer 声明 at 规则，使用 @layer 后跟一个或多个层的名称来声明层。
        @layer theme，layout，utilities;
        只要同名的层还不存在，这三个层(theme，layout，utilities;)就会被创建并添加到现有层列表的末尾。但是，如果同名的层已经存在，那么上述语句只会创建还没存在的两个新层。
        创建层：
            @layer page {
              h1 {
                text-decoration: overline;
                color: red;
              }
            }

    4、使用 @import 将样式表导入具名层和匿名层：
        @import url("dialog.css") layer(components.dialog); //将样式表导入components 层中的嵌套 dialog 层。




## CSS的盒子模型：
    1、编写 CSS 时你会发现，你的工作好像是围绕着一个一个盒子展开的——设置尺寸、颜色、位置，等等。
      CSS 布局主要是基于盒子模型。在你的页面上占用空间的每个盒子都有类似的属性：
        padding（内边距）：是指内容周围的空间。在下面的例子中，它是段落文本周围的空间。
        border（边框）：是紧接着内边距的线。
        margin（外边距）：是围绕元素边界外侧的空间。

        width：元素的宽度
        background-color：元素内容和内边距底下的颜色
        color：元素内容（通常是文本）的颜色
        text-shadow：为元素内的文本设置阴影
        display：设置元素的显示模式（继续阅读文章以了解更多细节）

    2、块级盒子（Block box）和 内联盒子（Inline box），这两种盒子会在页面流（page flow）和元素之间的关系方面表现出不同的行为：
        注意：我们通过对盒子display 属性的设置，比如 inline 或者 block ，来控制盒子的外部显示类型。

        1.块级的（block）盒子会表现出以下行为：
            ▪️ 盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽。
            ▪️ 每个盒子都会换行。
            ▪️ 设置 width 和 height 属性可以发挥作用。
            ▪️ 内边距（padding）, 外边距（margin）和 边框（border）会将其他元素从当前盒子周围“推开”。

        2.内联盒子（inline box）会表现以下行为：
            ▪️ 盒子不会产生换行。
            ▪️ 设置 width 和 height 属性将不起作用，意思是不会推开其他盒子，而是重叠在其他盒子上面。但是内外边距是起作用的。
            ▪️ 垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 inline 状态的盒子推开。
            ▪️ 水平方向的内边距、外边距以及边框会被应用且会把其他处于 inline 状态的盒子推开。

        注意：块级和内联布局是 web 上默认的行为--被称为 正常文档流，因为如果没有其他说明，我们的盒子布局默认是块级或者内联。

    3、我们通过对盒子display 属性的设置，比如 inline 或者 block ，来控制盒子的外部显示类型。
        1.如果设置 display: flex，在一个元素上，外部显示类型是 block，但是内部显示类型修改为 flex。该盒子的所有直接子元素都会成为 flex 元素，会根据弹性盒子（Flexbox）规则进行布局。

    4、盒模型的各个部分：
        标准盒模型：（默认浏览器会使用标准模型）
        ▪️ Content box: 这个区域是用来显示内容，大小可以通过设置 width 和 height.
        ▪️ Padding box: 包围在内容区域外部的空白区域；大小通过 padding 相关属性设置。
        ▪️ Border box: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。
        ▪️ Margin box: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。
            margin 不计入实际大小——当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止——不会延伸到 margin。

        替代（IE）盒模型：
            ▪️ IE盒模型的 width 和 height 值的计算：是包括了Padding和Border的宽度，即盒子实际可见的大小。
            ▪️ 如果需要使用替代模型，你可以通过为其设置 box-sizing: border-box 来实现。这样就可以告诉浏览器使用 border-box 来定义区域，从而设定你想要的大小。
                例如：  .box {
                          box-sizing: border-box;
                        }
    5、使用 display: inline-block：
        1.你不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免上面看到的重叠。
                设置width 和height 属性会生效。
                padding, margin, 以及border 会推开其他元素。


## 外边距折叠：
    1、如果你有两个外边距相接的元素，这些外边距将合并为一个外边距，即最大的单个外边距的大小。
        例如：顶部段落的页 margin-bottom为 50px。第二段的margin-top 为 30px。因为外边距折叠的概念，所以框之间的实际外边距是 50px，而不是两个外边距的总和。
    2、有许多规则规定了什么时候外边距会折叠，什么时候不会折叠。相关更多信息，请参阅外边距重叠。
    3、外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。

## 盒子模型和内联盒子(内联宽高的计算)：
    1、我们在一个段落中使用了<span>，并对其应用了宽度、高度、边距、边框和内边距。可以看到，宽度和高度被忽略了。外边距、内边距和边框是生效的，但它们不会改变其他内容与内联盒子的关系，因此内边距和边框会与段落中的其他单词重叠。
        也就是，内联盒子的宽高约束是无效的，设置了也没用，而它外边距、内边距和边框是生效的，但是会根据内联盒子的规则生效，也就是推开左右而已。
    
    2、特殊的内联边距值：使用 display: inline-block。
        你不希望一个项切换到新行，但希望它可以设定宽度和高度，并避免与内联的内容重叠。相当于在内联的规则里，把上下方向的内容也推开了(本来只推开左右)。

## 内容的溢出
    1、溢出是在盒子无法容纳下太多的内容的时候发生的，例如，通过给 width 和 height（或者 inline-size 和 block-size）赋值的方式来约束盒子的尺寸。
    2、overflow 属性，overflow 的默认值为 visible，这就是我们的内容溢出的时候，我们在默认情况下看到溢出的内容的原因。
        1. 设置 overflow-y: scroll 来仅在 y 轴方向滚动。

## 区块格式化上下文（Block Formatting Context，BFC）
    1、在你使用诸如 scroll 或者 auto 的时候，你就建立了一个块级排版上下文。结果就是，你改变了 overflow 的值的话，在容器之外的东西没法混进容器内，也没有内容可以溢出盒子，进入周围的版面。



## 用户代理(user agent)：
    用户代理是代表一个人的计算机程序，例如，一个在 Web 上的 浏览器。
    浏览器有时候也被称为 user agent，大致可以当这个程序是一个存在于计算机系统中的人。当我们讨论 CSS 时，浏览器是 User agent 的主要形式，然而它并不是唯一的一个。还有其他可用的 user agents — 像是那些可以把 HTML 和 CSS 文档转换为可以打印的 PDF 文档的软件。

## CSS的属性、声明、规则集：
    p {
        color: red; //属性和值。
        width: 500px;
        border: 1px solid black;
    }   
    单个 属性：值 就是CSS的属性和其值。如果属性未知或某个值对给定属性无效，则声明被视为无效，并被浏览器的 CSS 引擎完全忽略。
    在 大括号里面的东西 都是声明，也就是 所有的 属性：值 就是CSS的声明。
    声明 和 选择器 加起来就是CSS的规则集。

## 定义变量：
    1、例如我们创建了在下面的第一行里面叫做$base-color的变量，我们之后可以在样式表的任何需要这一颜色的地方使用它。
        $base-color: #c6538c;
        .alert {
          border: 1px solid $base-color;
        }

## CSS 的值与单位
    1、CSS 值倾向于使用尖括号表示，以区别于 CSS 属性（例如 color 属性和 <color> 数据类型）。也就是在解析文档中，color表示属性的描述，<color> 表示值的描述。
        1.CSS 中的值类型是一种定义了一些可使用的值的集合的方式，例如<color> 值，不管是关键字、十六进制值还是 rgb() 函数等都是有效的。

    2、CSS 中有两种类型的长度——相对长度和绝对长度：
      1.绝对长度：
        英寸 	1in = 2.54cm = 96px
        像素 	1px = 1/96th of 1in
        点 	    1pt = 1/72th of 1in

      2.相对长度单位相对于其他一些东西，比如父元素的字体大小，或者视图端口的大小。
        概括地说，在排版属性中 em 单位的意思是“父元素的字体大小”。
        概括地说，rem 单位的意思是“根元素的字体大小”。
        em 	在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。

     3.百分比：
        1.百分比的问题在于，它们总是相对于其他值设置的。例如，如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。
        2.注意，虽然许多值接受长度或百分比，但也有一些值只接受长度。你可以在 MDN 属性引用页面上看到它能接受哪些值。
          如果允许的值包括 <length-percentage>，则可以使用长度或百分比。如果允许的值只包含 <length>，则不可能使用百分比。

        3.使用百分比作为元素外边距（margin）或填充（padding）的单位时，值是以包含块的内联尺寸进行计算的，也就是元素的水平宽度。

    4.RGB 和 RGBA 的值：
        1.RGB 值是一个函数——rgb()——它有三个参数，表示颜色的红色、绿色和蓝色通道值，与十六进制值的方法非常相似。
          rgb() 传递第四个参数，它代表颜色的 alpha 通道，控制不透明度。如果你把这个值设置为 0，它将使颜色完全透明，而 1 将使它完全不透明。
          例如：rgb(2 121 139 / .3)

        2.在旧版本的 CSS 中，rgb() 语法不支持 alpha 参数——你需要使用另一个叫 rgba() 的函数来实现。

    5.位置，<position> 数据类型：
        一个典型的位置值由两个值组成——第一个值水平地设置位置，第二个值垂直地设置位置。如果只指定一个轴的值，另一个轴将默认为 center。

    6.字符串和标识符：
        1. 一个 CSS 可以理解的特殊值。因此它们没有使用引号括起来——它们不被当作字符串。（例如 <color> 关键字，如 red、black、rebeccapurple 和 goldenrod）
    
    7.视口单位：
        1.视口，即你在浏览器中看到的部分页面(相对父页面)，也是有尺寸的。1vh 等于视口高度的 1%，1vw 则为视口宽度的 1%。
    
## 原始尺寸与外部尺寸：
    1、原始尺寸，或固有尺寸：
        1.在受 CSS 设置影响之前，HTML 元素有其原始的尺寸。一个直观的例子就是图像。一幅图像的长和宽由这个图像文件自身确定。这个尺寸就是固有尺寸。
            元素的固有尺寸——由其所包含的内容决定。

    2、外部尺寸：当我们给元素指定尺寸（然后其内容需要适合该尺寸）时，我们将其称为外部尺寸。

## CSS中的函数：
    虽然大多数值是相对简单的关键字或数值，但也有一些值是以函数的形式出现的。
    例如：calc() 函数，这个函数允许在 CSS 中进行简单的计算
        .box {
          padding: 10px;
          width: calc(90% - 30px);
          color: white;
        }
    Transform 相关的函数，例如：
        .box {
          margin: 30px;
          transform: rotate(0.8turn);
        }

## CSS的@规则：
    1、CSS 的 @rules（读作“at-rules”）是一些特殊的规则，提供了关于 CSS 应该执行什么或如何表现的指令。
        @import 将一个样式表导入另一个 CSS 样式表：@import "styles2.css";
        @media，它被用来创建媒体查询。媒体查询使用条件逻辑来应用 CSS 样式。例如：
            body {
                background-color: pink;
            }

            @media (min-width: 30em) {  //如果浏览器的视口宽于 30em，接下来的媒体查询则定义了蓝色背景。
              body {
                background-color: blue;
              }
            }

## CSS 媒体查询（media query）：
    1、CSS 媒体查询（media query）是响应式设计的关键组成部分，你可以根据各种设备特征和参数是否存在以及对应的值来应用 CSS 样式。
        1.有条件的通过 @media 和 @import at-rules 用CSS 装饰样式。

        2.用 media= 属性为<style>, <link>, <source> (en-US)和其他HTML元素指定特定的媒体类型。如：
            <link rel="stylesheet" src="styles.css" media="screen" />
            <link rel="stylesheet" src="styles.css" media="print" />

        3.使用Window.matchMedia() 和MediaQueryList.addListener() 方法来测试和监控媒体状态。


## 简写属性：font、background、padding、border 和 margin 等属性
    1、它们允许在一行中设置多个属性值，从而节省时间并使代码更整洁。也就是赋值的时候有一些默认的行为。
        例如：
        /* 在像 padding 和 margin 这样的 4 值简写语法中，
           数值的应用顺序是上、右、下、左（从顶部顺时针方向）。
           也有其他的简写类型，例如 2 值简写，
           它为顶部/底部设置 padding/margin，然后是左侧/右侧 */
        padding: 10px 15px 15px 5px;

## CSS 的注释与空格：
    1、CSS 中的注释以 /* 开头，以 */ 结尾。
    2、空白是指实际的空格、制表符和换行符。就像浏览器忽略了 HTML 中的空白一样，浏览器也忽略了 CSS 中的空白。空白的价值在于它可以提高可读性。
    3、以分号或者逗号结尾，分号表明当前语段结束了，逗号表示语段停顿。

## 浏览器展示文件时，加载文件的基本流程：
    1、浏览器载入 HTML 文件（比如从网络上获取）。

    2、将 HTML 文件转化成一个 DOM（Document Object Model），DOM 是文件在计算机内存中的表现形式，下一节将更加详细的解释 DOM。

    3、接下来，浏览器会拉取该 HTML 相关的大部分资源，比如嵌入到页面的图片、视频和 CSS 样式。JavaScript 则会稍后进行处理，简单起见，同时此节主讲 CSS，所以这里对如何加载 JavaScript 不会展开叙述。

    4、浏览器拉取到 CSS 之后会进行解析，根据选择器的不同类型（比如 element、class、id 等等）把他们分到不同的“桶”中。浏览器基于它找到的不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id 选择器等）应用在对应的 DOM 的节点中，并添加节点依赖的样式（这个中间步骤称为渲染树）。

    5、上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。

    6、网页展示在屏幕上（这一步被称为着色）。

## 关于 DOM：
    1、一个 DOM 有一个树形结构，标记语言中的每一个元素、属性以及每一段文字都对应着结构树中的一个节点（Node/DOM 或 DOM node）。节点由节点本身和其他 DOM 节点的关系定义，有些节点有父节点，有些节点有兄弟节点（同级节点）。

    2、对于 DOM 的理解会很大程度上帮助你设计、调试和维护你的 CSS，因为 DOM 是你的 CSS 样式和文件内容的结合。当你使用浏览器 F12 调试的时候你需要操作 DOM 以查看使用了哪些规则。 

## 级联层 @layer：
    1、相当于打包一组规则集，导出给别人使用。
        @layer utilities {
          /* 创建一个名为 utilities 的级联层 */
        }

## 图像、媒体和表单元素：
    1、替换元素：图像和视频被描述为 替换元素。这意味着 CSS 不能影响它们的内部布局——而仅影响它们在页面上相对于其他元素的位置。

##  文本和字体样式：
    1、包含在元素中的文本是作为一个单一的实体。你不能将文字其中一部分选中或添加样式，如果你要这么做，那么你必须要用适合的元素来包装它们，比如 ( <span> 或者 <strong>), 或者使用伪元素，像::first-letter (选中元素文本的第一个字母), ::first-line (选中元素文本的第一行), 或者 ::selection (当前光标双击选中的文本)。

    2、color 属性设置选中元素的前景内容的颜色 (通常指文本，不过也包含一些其他东西，或者是使用 text-decoration 属性放置在文本下方或上方的线 (underline overline)。

    3、浏览器只会把在当前机器上可用的字体应用到当前正在访问的网站上；如果字体不可用，那么就会用浏览器默认的字体代替 default font。
       要在你的文本上设置一个不同的字体，你可以使用 font-family 属性，这个允许你为浏览器指定一个字体 (或者一个字体的列表)，然后浏览器可以将这种字体应用到选中的元素上。

    4、CSS 定义了 5 个常用的字体名称：serif, sans-serif, monospace, cursive, 和 fantasy. 

    5、字体栈 (font stack)：设置了之后，浏览器就有多种字体可以选择了，只需包含一个 font-family 属性，其值由几个用逗号分离的字体名称组成。
        比如：
        //浏览器从列表的第一个开始，然后查看在当前机器中，这个字体是否可用。如果可用，就把这个字体应用到选中的元素中。如果不可用，它就移到列表中的下一个字体，然后再检查。
        p {
             font-family: "Trebuchet MS", Verdana, sans-serif;
        }

    6、浏览器<html>的 font-size 标准设置的值为 16px，其他元素也许有默认的大小，也许没有。